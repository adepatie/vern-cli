#!/usr/bin/env node

var program          = require('commander'),
    os               = require('os'),
    path             = require('path'),
    fs               = require('fs-extra'),
    spawn            = require('child_process').spawn,
    fork             = require('child_process').fork,
    inquirer         = require('inquirer'),
    colors           = require('colors'),
    template_dir     = '../templates',
    _project         = require(template_dir + '/project'),
    _container       = require(template_dir + '/container'),
    _controller      = require(template_dir + '/controller'),
    _model           = require(template_dir + '/model'),
    _directive       = require(template_dir + '/directive'),
    _service         = require(template_dir + '/service'),
    _filter          = require(template_dir + '/filter'),
    _route           = require(template_dir + '/route'),
    _view            = require(template_dir + '/view'),
    _view_controller = require(template_dir + '/view_controller'),
    _stylesheet      = require(template_dir + '/stylesheet'),
    utils            = require('../utils'),
    default_config   = require(template_dir + '/vern_config.json'),
    pkg              = require('../package.json');

var installs = true;

if(process.argv.length <= 2) {
  return console.log('No command given, ' + 'vern -h'.green + ' for usage');
}

// This is so weird, must be a bug in commander or in child_process, when spawning a node process it seems to include the parameters from the vern cli call...
if(process.argv.indexOf('--no-install') > -1) {
  process.argv.splice(process.argv.indexOf('--no-install'), 1);
  installs = false;
}

program
  .version(pkg.version)
  .usage('<command> [options]')
  .option('create, --create <object> <name> [options]', 'Create a new module', parseCreate)
  .option('start, --start <server>', 'Start a server module (api, public, admin)', parseStart)
  .option('stop, --stop <server>', 'Stop a server module (api, public, admin)', parseStop)
  .option('restart, --restart <server>', 'Restart a server module (api, public, admin)', parseRestart)
  .option('install, --install [module.spec] [options]', 'Install a module into your project', parseInstall)
  .option('uninstall, --uninstall <module.spec> [options]', 'Uninstall a module from your project', parseUninstall)
  .option('build, --build [env]', 'Build for distribution, defaults to public', parseBuild)
  .option('package, --package [module.spec] [options]', 'Start the package builder', parsePackage)
  .option('deploy, --deploy [stage]', 'Create a view when inside a project folder', deployApp)
  .option('config, --config', 'Configure your app when inside a project folder', configApp)
  .parse(process.argv);

/*
 *
 * Starter functions
 *
 * These methods will start the api, admin, and public servers for development
 *
 * For a production deployment the process is different, but could be very similar
 *
 */
function parseStart(server) {
  if(!fs.existsSync(process.cwd() + '/vern.json')) {
    console.log('');
    console.log('No ' + 'vern.json'.red + ' found');
    console.log('');
    return;
  }

  var i = process.argv.indexOf('start');
  var params = process.argv.slice(i + 1);

  var projectConfig = require(process.cwd() + '/vern.json');
  switch(server) {
    case 'api':
      new Starter(projectConfig).startAPI(installs);
      break;
    case 'public':
      new Starter(projectConfig).startPublic(installs);
      break;
    case 'admin':
      new Starter(projectConfig).startAdmin(installs);
      break;
    case 'default':
    case 'all':
      new Starter(projectConfig).startAPI(installs, function() {
        new Starter(projectConfig).startPublic(installs, function () {
          new Starter(projectConfig).startAdmin(installs);
        });
      });
      break;
  }
}

/*
 *
 * Stop servers
 *
 * TODO
 *
 */
function parseStop(server) {
  if(!fs.existsSync(process.cwd() + '/vern.json')) {
    console.log('');
    console.log('No ' + 'vern.json'.red + ' found');
    console.log('');
    return;
  }

  var i = process.argv.indexOf('stop');
  var params = process.argv.slice(i + 1);

  var installs = true;
  if(params.indexOf('--no-install') > -1) {
    installs = false;
  }

  var projectConfig = require(process.cwd() + '/vern.json');
  switch(server) {
    case 'api':

      break;
    case 'public':

      break;
    case 'admin':

      break;
  }
}

/*
 *
 * Restart servers
 *
 * TODO
 *
 */
function parseRestart(server) {
  if(!fs.existsSync(process.cwd() + '/vern.json')) {
    console.log('');
    console.log('No ' + 'vern.json'.red + ' found');
    console.log('');
    return;
  }

  var i = process.argv.indexOf('restart');
  var params = process.argv.slice(i + 1);

  var installs = true;
  if(params.indexOf('--no-install') > -1) {
    installs = false;
  }

  var projectConfig = require(process.cwd() + '/vern.json');
  switch(server) {
    case 'api':

      break;
    case 'public':

      break;
    case 'admin':

      break;
  }
}

function Starter(options) {
  var $scope = this;

  $scope.processes = {
    vern: null,
    admin: null,
    public: null
  };

  var projectConfig = new Builds().loadProjectConfig();
  if(!projectConfig) return;

  var project_dirs = {
    vern: '/app/' + projectConfig.options.folders.api,
    admin: '/app/' + projectConfig.options.folders.admin,
    assets: '/app/' + projectConfig.options.folders.assets,
    public: '/app/' + projectConfig.options.folders.public
  };

  process.on('exit', function(code) {
    if($scope.processes.vern) {
      $scope.processes.vern.kill();
    }

    if($scope.processes.admin) {
      $scope.processes.admin.kill();
    }

    if($scope.processes.public) {
      $scope.processes.public.kill();
    }
  });

  var cwd = options.cwd || process.cwd();

  $scope.handleRunner = function(task, runner, callback) {
    runner.on('close', function(code) {
      if(code === 0) {
        callback(null, task + ' successful'.green);
      } else {
        callback(task + ' exited with '.red + code.red, null)
      }
    });

    runner.on('error', function(message) {
      console.log('here');
    });
  };

  $scope.runNpm = function(cmd_path, callback) {
    console.log('running npm in ' + cmd_path);
    var runner = spawn('npm', ['install'], {
      cwd: cmd_path,
      stdio: 'inherit'
    });
    $scope.handleRunner('npm install in ' + cmd_path, runner, function(err, success) {
      if (err) {
        return callback(err);
      }

      return callback(null, success);
    });
  };

  $scope.runBower = function(cmd_path, callback) {
    console.log('running bower in ' + cmd_path);
    var runner = spawn('bower', ['install'], {
      cwd: cmd_path,
      stdio: 'inherit'
    });
    $scope.handleRunner('bower install in ' + cmd_path, runner, function(err, success) {
      if (err) {
        return callback(err);
      }

      return callback(null, success);
    });
  };

  $scope.vernExec = function(opts) {
    var env = opts.env || 'development';
    var project = opts.project || 'vern';

    $scope.processes[project] = spawn('node', ['server', '-e', env], {
      cwd: cwd + project_dirs[project],
      stdio: 'pipe'
    });

    console.log('');
    console.log('starting ' + project.green + ' with PID ' + $scope.processes[project].pid.toString().green + ' ...');
    console.log('');

    $scope.processes[project].stdout.on('data', function(data) {
      process.stdout.write(project + ': ' + data.toString());
    });
    $scope.processes[project].stderr.on('data', function(data) {
      process.stdout.write(project + ' ERROR: '.red + data.toString());
    });
    $scope.processes[project].on('error', function() {
      console.dir(arguments);
    });
  };

  $scope.gruntExec = function(opts) {
    var project = opts.project || 'public';

    $scope.processes[project] = spawn('grunt', ['server'], {
      cwd: cwd + project_dirs[project],
      stdio: 'pipe'
    });

    console.log('');
    console.log('starting ' + project.green + ' with PID ' + $scope.processes[project].pid.toString().green + ' ...');
    console.log('');

    $scope.processes[project].stdout.on('data', function(data) {
      process.stdout.write(project + ': ' + data.toString());
    });
    $scope.processes[project].stderr.on('data', function(data) {
      process.stdout.write(project + ' ERROR: '.red + data.toString());
    });
  };

  $scope.startAPI = function(install, nostart, callback) {
    if(arguments.length === 1 && typeof arguments[0] === 'function') {
      callback = arguments[0];
    }
    if(arguments.length === 2 && typeof arguments[1] === 'function') {
      callback = arguments[1];
    }
    if(install === true) {
      $scope.runNpm(cwd + project_dirs['vern'], function(err, success) {
        if(err) {
          return console.log(err);
        }
        console.log(success);

        if(nostart !== true) {
          $scope.vernExec({project: 'vern', env: 'development'});
        }
        if(callback) {
          callback(null, 'api started');
        }
      });
    } else {
      $scope.vernExec({project: 'vern', env: 'development'});
      if(callback) {
        callback(null, 'api started');
      }
    }
  };

  $scope.startPublic = function(install, nostart, callback) {
    if(arguments.length === 1 && typeof arguments[0] === 'function') {
      callback = arguments[0];
    }
    if(arguments.length === 2 && typeof arguments[1] === 'function') {
      callback = arguments[1];
    }
    if(install === true) {
      $scope.runNpm(cwd + project_dirs['public'], function(err, success) {
        if(err) {
          return console.log(err);
        }

        console.log(success);
        console.log('');
        $scope.runBower(cwd + project_dirs['public'], function(err, success) {
          if(err) {
            return console.log(err);
          }

          console.log(success);
          if(nostart !== true) {
            $scope.gruntExec({project: 'public'});
          }
          if(callback) {
            callback(null, 'api started');
          }
        });
      });
    } else {
      $scope.gruntExec({project: 'public'});
      if(callback) {
        callback(null, 'api started');
      }
    }
  };

  $scope.startAdmin = function(install, nostart, callback) {
    if(arguments.length === 1 && typeof arguments[0] === 'function') {
      callback = arguments[0];
    }
    if(arguments.length === 2 && typeof arguments[1] === 'function') {
      callback = arguments[1];
    }
    if(install === true) {
      $scope.runNpm(cwd + project_dirs['admin'], function(err, success) {
        if(err) {
          return console.log(err);
        }

        console.log(success);
        console.log('');
        $scope.runBower(cwd + project_dirs['admin'], function(err, success) {
          if(err) {
            return console.log(err);
          }

          console.log(success);
          if(nostart !== true) {
            $scope.gruntExec({project: 'admin'});
          }
          if(callback) {
            callback(null, 'api started');
          }
        });
      });
    } else {
      $scope.gruntExec({project: 'admin'});
      if(callback) {
        callback(null, 'api started');
      }
    }
  };

  return $scope;
}

/*
 *
 * Build functions
 *
 * These create the necessary templates and configurations for each type of component
 *
 * PROJECT LEVEL
 * ===
 * Project - Set up a complete vern structure
 * Container - Set up a container to be packaged and installed in projects (needs more explanation)
 *
 * API/BACKEND LEVEL
 * ===
 * Controller - Set up a vern route/data controller
 * Model - Set up a vern data model
 *
 * ANGULAR LEVEL (specify admin or public)
 * ===
 * View - Sets up an angular view + stylesheet + controller
 * Directive - Sets up an angular directive
 * Service - Sets up an angular service
 * Filter - Sets up an angular filter
 *
 */

function parseCreate() {
  var i = process.argv.indexOf('create');
  var params = process.argv.slice(i + 1);

  for(var j = 0; j < params.length; j++) {
    if(!params[j].length) {
      params.splice(j, 1);
      j--;
    }
  }
  var buildName = params[0];
  buildName = utils.toCamelCase(buildName);
  new Builds()['build' + buildName](params.slice(1));
}

function Builds() {
  var $scope = this;

  var cwd = process.cwd();

  $scope.buildProject = function(options) {
    var project_path = options[0];
    var project = null;

    if(!project_path) {
      inquirer.prompt([
        {
          type: 'input',
          name: 'project',
          message: 'Enter a project name (use . for current directory)'
        }
      ], function(answers) {
        var project_name = answers.project.length ? answers.project : '.';
        build(project_name, project_name);
      })

    } else {
      if(project_path === '.') {
        project = cwd.split('/').pop();
      } else {
        project = project_path.split('/').pop();
      }
      build(project_path, project);
    }

    function build(project_path, project) {
      project_path = utils.toHyphenated(project_path);
      project = utils.toCamelCase(project);
      default_config.module = project;

      var params = {
        path: project_path,
        projectName: project,
        appName: project + 'App',
        adminAppName: project + 'AdminApp',
        apiName: 'vern',
        adminName: 'vern_admin',
        assetsName: 'vern_assets',
        publicName: 'vern_public'
      };

      inquirer.prompt([
        {
          type: 'confirm',
          name: 'customize',
          message: 'Do you want to customize your project folders?',
          default: false
        }
      ], function(answers) {
        if(answers.customize === true) {
          inquirer.prompt([
            {
              type: 'input',
              name: 'api_name',
              message: 'Name your API server',
              default: 'vern'
            },
            {
              type: 'input',
              name: 'admin_name',
              message: 'Name your Admin web portal',
              default: 'vern_admin'
            },
            {
              type: 'input',
              name: 'assets_name',
              message: 'Name your Assets directory',
              default: 'vern_assets'
            },
            {
              type: 'input',
              name: 'public_name',
              message: 'Name your public',
              default: 'vern_public'
            }
          ], function (answers) {
            params.projectName = project;
            params.appName = project + 'App';
            params.adminAppName = project + 'AdminApp';
            params.apiName = utils.toHyphenated(answers.api_name);
            params.adminName = utils.toHyphenated(answers.admin_name);
            params.assetsName = utils.toHyphenated(answers.assets_name);
            params.publicName = utils.toHyphenated(answers.public_name);

            console.log('Setting up ' + project.green + ' now!');
            if ((fs.existsSync(project_path) && project_path !== '.') || (project_path === '.' && fs.readdirSync(project_path).length > 0)) {
              inquirer.prompt({
                type: 'confirm',
                name: 'overwrite',
                message: 'Overwrite the existing directory?',
                default: false
              }, function (answers) {
                if (answers.overwrite === true) {
                  copyProject(project_path, params);
                } else {
                  console.log('Not going to overwrite. Good bye!'.red);
                }
              });
            } else {
              copyProject(project_path, params);
            }
          });
        } else {
          copyProject(project_path, params);
        }
      });
    }
  };

  function copyProject(project_path, params) {
    console.log('Trying to create project in: ' + project_path.green);
    default_config.folders.api = params.apiName;
    default_config.folders.admin = params.adminName;
    default_config.folders.assets = params.assetsName;
    default_config.folders.public = params.publicName;
    _project.copy(params, function(err, res) {
      if(err) {
        console.log('');
        console.log(err);
        return;
      }

      console.log(res.green);

      fs.copySync(project_path + '/app/' + params.apiName + '/vern_config.sample.js'
        , project_path + '/app/' + params.apiName + '/vern_config.js');

      fs.outputJson(project_path + '/vern.json', default_config, function(err) {
        if(err) {
          return console.log(err);
        }

        console.log('Created ' + (project_path + '/vern.json').green);
        // Now we will prompt the user to start adding base routes, controllers, and models.
        // We can also setup a deployment strategy(ies)
        inquirer.prompt({
          type: 'confirm',
          name: 'install',
          message: 'Would you like to install all dependencies now? It will take a few minutes.',
          default: false
        }, function(answers) {
          if(answers.install === true) {
            var newCWD = path.join(cwd, project_path);
            new Starter({cwd: newCWD}).startAPI(true, true, function(err, success) {
              if(err) {
                return console.log(err);
              }
              new Starter({cwd: newCWD}).startPublic(true, true, function (err, success) {
                if(err) {
                  return console.log(err);
                }
                new Starter({cwd: newCWD}).startAdmin(true, true, function (err, success) {
                  if(err) {
                    return console.log(err);
                  }

                  console.log('');
                  console.log('All servers dependencies installed!');
                  console.log('');
                  console.log('To start servers: ' + 'cd '.green + project_path.green);
                  console.log('Then run ' + 'vern start all'.green);
                  console.log('');
                });
              });
            });
          } else {
            console.log('');
            console.log('You can start your servers by running ' + 'vern start all'.green);
            console.log('');
          }
        });
      });
    });
  }

  $scope.ensureOptions = function(options, starting) {
    if(!starting) {
      starting = default_config;
    }
    for(var i in starting) {
      if(typeof options[i] === 'undefined') {
        options[i] = starting[i];
      }
      if(typeof starting[i] === 'object') {
        options[i] = $scope.ensureOptions(options[i], starting[i]);
      }
    }

    return options;
  };

  $scope.loadProjectConfig = function(project_path) {
    if(!project_path) {
      project_path = cwd + '/vern.json';
    }

    var done = false;

    while(!done) {
      if (fs.existsSync(project_path)) {
        cwd = path.dirname(project_path);
        var options = require(cwd + '/vern.json');
        options = $scope.ensureOptions(options);
        fs.outputJsonSync(cwd + '/vern.json', options);
        return {options: options, cwd: cwd};
      }
      if(path.dirname(project_path) === '/') {
        done = true;
        continue;
      }
      project_path = path.normalize(path.dirname(project_path) + '/../' + 'vern.json');
    }

    console.log('');
    console.log('No ' + 'vern.json'.red + ' found');
    console.log('');
    return null;
  };

  $scope.buildContainer = function(options) {

  };

  $scope.buildController = function(options) {
    var model = null;
    if(options.indexOf('--model') > -1) {
      model = options[options.indexOf('--model') + 1];
    }

    var name = utils.toCamelCase(options[0]);

    if(!model && options.indexOf('--no-model') < 0) {
      inquirer.prompt({
        type: 'confirm',
        name: 'model',
        message: 'Would you like to create ' + name + 'Model?',
        default: true
      }, function(res) {
        if(res.model === true) {
          model = name + 'Model';
          $scope.buildModel([options[0].toLowerCase()]);
        }
        finishControllerBuild(options, model);
      });
    } else {
      finishControllerBuild(options, model);
    }
  };

  function finishControllerBuild(options, model) {
    var projectConfig = $scope.loadProjectConfig();
    if(!projectConfig) return;

    var params = {
      name: utils.toCamelCase(options[0]) + 'Controller',
      path: cwd + '/app/' + projectConfig.options.folders.api + '/controllers'
    };

    if(model) {
      params.model_declaration = '$scope.model = $vern.models.' + model + ';';
    }

    _controller.copy(params, function(err, success) {
      if(err) {
        return console.log(err);
      }

      utils.rewrite({
        path: cwd + '/app/' + projectConfig.options.folders.api + '/server.js',
        needle: '// buildpoint',
        insertions: [
            '$vern.controllers.' + utils.toCamelCase(options[0], true) + ' = new $vern.controllers.' + params.name + '($vern).init({',
          model ? '  model: $vern.models.' + model + ',' : '',
            '  publicRoute: \'/' + utils.toHyphenated(options[0]) + '\',',
            '  //publicPostRoute: \'/' + utils.toHyphenated(options[0]) + '\',',
            '  //publicDeleteRoute: \'/' + utils.toHyphenated(options[0]) + '\',',
          '});'
        ]
      });

      console.log('');
      console.log(success.green);
      console.log('');
    });
  }

  $scope.buildModel = function(options) {
    var projectConfig = $scope.loadProjectConfig();
    if(!projectConfig) return;

    var params = {
      name: utils.toCamelCase(options[0]) + 'Model',
      path: cwd + '/app/' + projectConfig.options.folders.api + '/models',
      collection: options[0].toLowerCase(),
      indexes: [],
      exclude: [],
      validations: {},
      validation_exceptions: {},
      non_editable: [],
      super_constructor: null
    };

    _model.copy(params, function(err, success) {
      if(err) {
        return console.log(err);
      }

      console.log('');
      console.log(success.green);
      console.log('');
    });
  };

  $scope.buildService = function(options) {
    var projectConfig = $scope.loadProjectConfig();
    if(!projectConfig) return;

    if(options.length < 1) {
      console.log('');
      console.log('You must specify a name'.red);
      console.log('');
      return;
    }

    options[0] = utils.toHyphenated(options[0]);
    options[1] = utils.toHyphenated(options[1]);

    options[0] = options[0].toLowerCase();
    if(['admin', 'public'].indexOf(options[0]) <= -1) {
      options[1] = options[0];
      options[0] = 'public';
    }

    var type = 'service';
    if(options.indexOf('--use-factory') > -1) {
      type = 'factory';
    }
    if(options.indexOf('--use-provider') > -1) {
      type = 'provider';
    }

    var env = options[0] === 'admin' ? projectConfig.options.folders.admin : projectConfig.options.folders.public;

    var name = utils.toCamelCase(options[1], true);

    var params = {
      appName: projectConfig.options.module + (options[0] === 'admin' ? 'AdminApp' : 'App'),
      name: name,
      type: type,
      service_path: cwd + '/app/' + env + '/app/scripts/services'
    };

    _service.copy(params, function(err, success) {
      if(err) {
        return console.log(err);
      }

      utils.rewrite({
        path: cwd + '/app/' + env + '/app/index.html',
        needle: '<!-- endbuild -->',
        insertions: [
            '<script type="text/javascript" src="scripts/services/' + params.name + '.js"></script>'
        ]
      });

      console.log('');
      console.log(success.green);
      console.log('');
    });
  };

  $scope.buildDirective = function(options) {
    var projectConfig = $scope.loadProjectConfig();
    if(!projectConfig) return;

    if(options.length < 1) {
      console.log('');
      console.log('You must specify a name'.red);
      console.log('');
      return;
    }

    options[0] = utils.toHyphenated(options[0]);
    options[1] = utils.toHyphenated(options[1]);

    options[0] = options[0].toLowerCase();
    if(['admin', 'public'].indexOf(options[0]) <= -1) {
      options[1] = options[0];
      options[0] = 'public';
    }

    inquirer.prompt([{
      type: 'checkbox',
      name: 'needs',
      message: 'Select directive needs and press ENTER',
      choices: [
        {name: 'Element Restriction', checked: true},
        {name: 'Attribute Restriction', checked: true},
        {name: 'Class Restriction', checked: true},
        {name: 'Isolated Scope', checked: true},
        {name: 'Inherited Scope', checked: false},
        {name: '$templateCache', checked: true},
        {name: 'LESS File', checked: true}
      ]
    }], function(res) {
      var env = options[0] === 'admin' ? projectConfig.options.folders.admin : projectConfig.options.folders.public;

      var name = options[1].toLowerCase();
      var directive_name = utils.toCamelCase(options[1], true);

      var restrictions = (res.needs.indexOf('Element Restriction') > -1) ? 'E' : '';
      restrictions += (res.needs.indexOf('Attribute Restriction') > -1) ? 'A' : '';
      restrictions += (res.needs.indexOf('Class Restriction') > -1) ? 'C' : '';

      var params = {
        appName: projectConfig.options.module + (options[0] === 'admin' ? 'AdminApp' : 'App'),
        name: name,
        directive_name: directive_name,
        directive_path: cwd + '/app/' + env + '/app/scripts/directives',
        less_path: cwd + '/app/' + env + '/app/styles/less/directives',
        scope: (res.needs.indexOf('Inherited Scope') > -1),
        restrictions: restrictions,
        templateCache: (res.needs.indexOf('$templateCache') > -1),
        lessFile: (res.needs.indexOf('LESS File') > -1)
      };

      if(res.needs.indexOf('Isolated Scope') > -1) {
        params.scope = 'scope: {},';
      } else if(params.scope === true) {
        params.scope = 'scope: true,';
      }

      _directive.copy(params, function(err, success) {
        if(err) {
          return console.log(err);
        }

        utils.rewrite({
          path: cwd + '/app/' + env + '/app/index.html',
          needle: '<!-- endbuild -->',
          insertions: [
              '<script type="text/javascript" src="scripts/directives/' + params.name + '.js"></script>'
          ]
        });

        if(params.lessFile) {
          utils.rewrite({
            path: cwd + '/app/' + env + '/app/styles/less/main.less',
            needle: '// buildpoint',
            insertions: [
                '@import "directives/' + params.name + '.less";'
            ]
          });
        }

        console.log('');
        console.log(success.green);
        console.log('');
      });
    });
  };

  $scope.buildFilter = function(options) {
    var projectConfig = $scope.loadProjectConfig();
    if(!projectConfig) return;

    if(options.length < 1) {
      console.log('');
      console.log('You must specify a name'.red);
      console.log('');
      return;
    }

    options[0] = utils.toHyphenated(options[0]);
    options[1] = utils.toHyphenated(options[1]);

    options[0] = options[0].toLowerCase();
    if(['admin', 'public'].indexOf(options[0]) <= -1) {
      options[1] = options[0];
      options[0] = 'public';
    }

    var env = options[0] === 'admin' ? projectConfig.options.folders.admin : projectConfig.options.folders.public;

    var name = options[1].toLowerCase();
    var filter_name = utils.toCamelCase(options[1], true);

    var params = {
      appName: projectConfig.options.module + (options[0] === 'admin' ? 'AdminApp' : 'App'),
      name: name,
      filter_name: filter_name,
      filter_path: cwd + '/app/' + env + '/app/scripts/filters'
    };

    _filter.copy(params, function(err, success) {
      if(err) {
        return console.log(err);
      }

      utils.rewrite({
        path: cwd + '/app/' + env + '/app/index.html',
        needle: '<!-- endbuild -->',
        insertions: [
            '<script type="text/javascript" src="scripts/filters/' + params.name + '.js"></script>'
        ]
      });

      console.log('');
      console.log(success.green);
      console.log('');
    });
  };

  $scope.buildRoute = function(options) {
    $scope.buildView(options);
    $scope.buildViewController(options);
    $scope.buildStylesheet(options);
  };

  $scope.buildView = function(options) {
    var projectConfig = $scope.loadProjectConfig();
    if(!projectConfig) return;

    if(options.length < 1) {
      console.log('');
      console.log('You must specify a name'.red);
      console.log('');
      return;
    }

    options[0] = utils.toHyphenated(options[0]);
    options[1] = utils.toHyphenated(options[1]);

    options[0] = options[0].toLowerCase();
    if(['admin', 'public'].indexOf(options[0]) <= -1) {
      options[1] = options[0];
      options[0] = 'public';
    }

    var env = options[0] === 'admin' ? projectConfig.options.folders.admin : projectConfig.options.folders.public;

    var extraPath = '/main';
    if(options.indexOf('--partial') > -1) {
      extraPath = '/partials';
    }
    if(options.indexOf('--modal') > -1) {
      extraPath = '/modals';
    }
    /*
      Create a view in a path relative to /app/views
     */
    if(options.indexOf('--path') > -1) {
      extraPath = options[options.indexOf('--path') + 1];
    }

    if(extraPath.charAt(0) !== '/') {
      extraPath = '/' + extraPath;
    }

    var name = options[1].toLowerCase();
    var action = 'index';
    if(name.indexOf(':') > -1) {
      var parts = name.split(':');
      name = parts[0];
      action = parts[1];
    }

    var params = {
      appName: projectConfig.options.module + (options[0] === 'admin' ? 'AdminApp' : 'App'),
      name: name,
      action: action,
      view_path: cwd + '/app/' + env + '/app/views' + extraPath + '/' + name
    };

    _view.copy(params, function(err, success) {
      if(err) {
        return console.log(err);
      }
      console.log('');
      console.log(success.green);
      console.log('');
    });
  };

  $scope.buildViewController = function(options) {
    var projectConfig = $scope.loadProjectConfig();
    if(!projectConfig) return;

    if(options.length < 1) {
      console.log('');
      console.log('You must specify a name'.red);
      console.log('');
      return;
    }

    options[0] = utils.toHyphenated(options[0]);
    options[1] = utils.toHyphenated(options[1]);

    options[0] = options[0].toLowerCase();
    if(['admin', 'public'].indexOf(options[0]) <= -1) {
      options[1] = options[0];
      options[0] = 'public';
    }

    var env = options[0] === 'admin' ? projectConfig.options.folders.admin : projectConfig.options.folders.public;

    var name = options[1].toLowerCase();

    var controller_name = utils.toCamelCase(name, true);

    var params = {
      appName: projectConfig.options.module + (options[0] === 'admin' ? 'AdminApp' : 'App'),
      name: name,
      controller_name: controller_name,
      controller_path: cwd + '/app/' + env + '/app/scripts/controllers'
    };

    _view_controller.copy(params, function(err, success) {
      if(err) {
        return console.log(err);
      }

      utils.rewrite({
        path: cwd + '/app/' + env + '/app/index.html',
        needle: '<!-- endbuild -->',
        insertions: [
            '<script type="text/javascript" src="scripts/controllers/' + params.name + '.js"></script>'
        ]
      });

      console.log('');
      console.log(success.green);
      console.log('');
    });
  };

  $scope.buildStylesheet = function(options) {
    var projectConfig = $scope.loadProjectConfig();
    if(!projectConfig) return;

    if(options.length < 1) {
      console.log('');
      console.log('You must specify a name'.red);
      console.log('');
      return;
    }

    options[0] = utils.toHyphenated(options[0]);
    options[1] = utils.toHyphenated(options[1]);

    options[0] = options[0].toLowerCase();
    if(['admin', 'public'].indexOf(options[0]) <= -1) {
      options[1] = options[0];
      options[0] = 'public';
    }

    var env = options[0] === 'admin' ? projectConfig.options.folders.admin : projectConfig.options.folders.public;

    var name = options[1].toLowerCase();

    var controller_name = utils.toCamelCase(name, true);

    var params = {
      appName: projectConfig.options.module + (options[0] === 'admin' ? 'AdminApp' : 'App'),
      name: name,
      style_path: cwd + '/app/' + env + '/app/styles/less'
    };

    _stylesheet.copy(params, function(err, success) {
      if(err) {
        return console.log(err);
      }

      utils.rewrite({
        path: cwd + '/app/' + env + '/app/styles/less/main.less',
        needle: '// buildpoint',
        insertions: [
            '@import "' + params.name + '.less";'
        ]
      });

      console.log('');
      console.log(success.green);
      console.log('');
    });
  };

  return $scope;
}

/*
 *
 * Install functions
 *
 * These methods are used to install npm/bower modules AND vern containers
 *
 * Installs for npm/bower should specify which vern component they are
 * installing to (vern, admin, assets, public)
 *
 */
function parseInstall() {
  var i = process.argv.indexOf('install');
  var params = process.argv.slice(i + 1);

  var installName = params[0];
  installName = installName.charAt(0).toUpperCase() + installName.slice(1).toLowerCase();
  new Installs()['install' + installName](params.slice(1));
}

function parseUninstall() {
  var i = process.argv.indexOf('uninstall');
  var params = process.argv.slice(i + 1);

  var installName = params[0];
  installName = installName.charAt(0).toUpperCase() + installName.slice(1).toLowerCase();
  new Installs()['uninstall' + installName](params.slice(1));
}

function Installs(opts) {
  var $scope = this;

  var cwd = process.cwd();

  function npmCommand(type, options) {
    var projectConfig = new Builds().loadProjectConfig();
    if(!projectConfig) return;

    if(options.length < 1) {
      console.log('');
      console.log('You must specify an environment modules: api, admin, public'.red);
      console.log('');
      return;
    }

    if(['api', 'admin', 'public'].indexOf(options[0]) <= -1) {
      console.log('');
      console.log('You must specify an environment modules: api, admin, public'.red);
      console.log('');
      return;
    }

    var save = '--save';
    if(options.indexOf('--no-save') > -1) {
      save = null;
    }

    var params = [type, options[1], save];
    if(type === 'uninstall' && options.length < 2) {
      console.log('');
      console.log('You must specify a package name: `vern '.red + type.red + ' npm <environment> <package_name>`'.red);
      console.log('');
    } else if(options.length < 2 && type === 'install') {
      options[1] = '';
      params.splice(1, 2);
    }

    var env = options[0] === 'api' ? projectConfig.options.folders.api : (options[0] === 'admin' ? projectConfig.options.folders.admin : projectConfig.options.folders.public);

    var dir = projectConfig.cwd + '/app/' + env;

    var runner = spawn('npm', params, {
      cwd: dir,
      stdio: 'inherit'
    });

    var error = false;
    runner.on('close', function(code) {
      if(error) {
        return;
      }

      if(!options[1].length) {
        options[1] = 'all modules';
      }

      if(code > 0) {
        console.log('');
        console.log('npm ' + type + ' of ' + options[1].red + ' unsuccessful, exit code: ' + code);
        console.log('');
        return;
      }
      console.log('');
      console.log('npm ' + type + ' of ' + options[1].green + ' complete');
      console.log('');
    }).on('error', function(err) {
      error = true;
      console.log('');
      console.log(err.toString().red);
      console.log('');
    });
  }

  function bowerCommand(type, options) {
    var projectConfig = new Builds().loadProjectConfig();
    if(!projectConfig) return;

    if(options.length < 1) {
      console.log('');
      console.log('You must specify an environment modules: admin, public'.red);
      console.log('');
      return;
    }

    if(['admin', 'public'].indexOf(options[0]) <= -1) {
      console.log('');
      console.log('You must specify an environment modules: admin, public'.red);
      console.log('');
      return;
    }

    var save = '--save';
    if(options.indexOf('--no-save') > -1) {
      save = null;
    }

    var params = [type, options[1], save];
    if(type === 'uninstall' && options.length < 2) {
      console.log('');
      console.log('You must specify a package name: `vern '.red + type.red + ' bower <environment> <package_name>`'.red);
      console.log('');
    } else if(options.length < 2 && type === 'install') {
      options[1] = '';
      params.splice(1, 2);
    }

    var env = options[0] === 'admin' ? projectConfig.options.folders.admin : projectConfig.options.folders.public;

    var dir = projectConfig.cwd + '/app/' + env;

    var runner = spawn('bower', params, {
      cwd: dir,
      stdio: 'inherit'
    });

    var error = false;
    runner.on('close', function(code) {
      if(error) {
        return;
      }

      if(!options[1]) {
        options[1] = 'all modules';
      }

      if(code > 0) {
        console.log('');
        console.log('bower ' + type + ' of ' + options[1].red + ' unsuccessful, exit code: ' + code);
        console.log('');
        return;
      }
      console.log('');
      console.log('bower ' + type + ' of ' + options[1].green + ' complete');
      console.log('');
    }).on('error', function(err) {
      error = true;
      console.log('');
      console.log(err.toString().red);
      console.log('');
    });
  }

  $scope.installNpm = function(options) {
    npmCommand('install', options);
  };

  $scope.uninstallNpm = function(options) {
    npmCommand('uninstall', options);
  };

  $scope.installBower = function(options) {
    bowerCommand('install', options);
  };

  $scope.uninstallBower = function(options) {
    bowerCommand('uninstall', options);
  };

  $scope.installContainer = function(options) {
    console.log('');
    console.log('Coming soon...');
    console.log('');
  };

  $scope.uninstallContainer = function(params) {
    console.log('');
    console.log('Coming soon...');
    console.log('');
  };

  return $scope;
}

function parseBuild() {
  var i = process.argv.indexOf('build');
  var params = process.argv.slice(i + 1);

  var env = 'public';
  if(params[0]) {
    env = params[0];
  }
  new Distribution()['build' + utils.toCamelCase(env)](params);
}

function Distribution(opts) {
  var $scope = this;
  var projectConfig = new Builds().loadProjectConfig();

  function execBuild(env, dir) {
    var runner = spawn('grunt', ['build'], {
      cwd: dir,
      stdio: 'inherit'
    });

    runner.on('close', function(code) {
      if(code > 0) {
        console.log('');
        console.log('build of ' + env.red + ' unsuccessful, exit code: ' + code);
        console.log('');
        return;
      }
      console.log('');
      console.log('build of ' + env.green + ' complete');
      console.log('');
    }).on('error', function(err) {
      console.log('');
      console.log(err.toString().red);
      console.log('');
    });
  }

  $scope.buildPublic = function(params) {
    if(!projectConfig) return;
    var env = projectConfig.options.folders.public;
    var dir = projectConfig.cwd + '/app/' + env;

    if(!fs.existsSync(path.join(dir, 'node_modules'))) {
      new Starter({cwd: projectConfig.cwd}).startPublic(true, true, function (err, success) {
        if(err) {
          return console.log(err);
        }

        execBuild(env, dir);
      });
      return;
    }

    execBuild(env, dir);
  };

  $scope.buildAdmin = function(params) {
    if(!projectConfig) return;
    var env = projectConfig.options.folders.admin;
    var dir = projectConfig.cwd + '/app/' + env;

    if(!fs.existsSync(path.join(dir, 'node_modules'))) {
      new Starter({cwd: projectConfig.cwd}).startPublic(true, true, function (err, success) {
        if(err) {
          return console.log(err);
        }

        execBuild(env, dir);
      });
      return;
    }

    execBuild(env, dir);
  };

  return $scope;
}

/*
 *
 * Package functions
 *
 * These are used to package containers which can be deployed into a project.
 *
 * Packages can be specified for vern/api, admin, assets, or public projects
 *
 */
function parsePackage() {
  var i = process.argv.indexOf('package');
  var params = process.argv.slice(i + 1);
}

function Packages() {
  var $scope = this;

  return $scope;
}

function deployApp(stage) {
  console.log('');
  console.log('Upgrade to enterprise for access to deployment services'.red);
  console.log('');
}

function configApp() {

}